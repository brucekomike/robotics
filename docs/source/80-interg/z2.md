# 总复习2

**2022年11月14日**

---

## 考试

**时间:** 待定
**地点:** 待定

**题型:** 填空10分, 选择10分, 判断10分, 简答40分, 程序与计算30分 (自由度计算15分, PLC程序设计15分)。

**参考PPT, 认真复习。**

---

## 1. 机器人控制系统的组成与结构

**机器人控制器:** 是根据指令以及传感器信息控制机器人完成一定动作或作业任务的装置,是决定机器人功能和性能的主要因素,也是机器人系统中更新和发展最快的部分。

* **控制系统软件**
* **控制系统硬件**
* **示教器(示教与记忆)**

---

## 2. 机器人控制系统的分类

机器人控制系统组织结构分为三类:

### 集中式控制系统结构

用一台计算机(PC)实现全部控制功能, 充分利用了PC资源开放性的特点, 可以实现很好的开放性: 多种控制卡, 传感器设备等都可以通过标准PCI插槽或通过标准串口、并口集成到控制系统中。

* **优点:** 硬件成本较低, 便于信息的采集和分析, 易于实现系统的最优控制, 整体性与协调性较好, 基于PC的系统硬件扩展较为方便。
* **缺点:**
    * **灵活性差:** 控制危险容易集中, 一旦出现故障, 其影响面广, 后果严重。
    * **实时性差:** 由于工业机器人的实时性要求很高, 当系统进行大量数据计算, 会降低系统实时性, 系统对多任务的响应能力也会与系统的实时性相冲突。
    * **可靠性差:** 系统连线复杂, 会降低系统的可靠性。

### 主从式控制系统结构

采用主、从两级处理器实现系统的全部控制功能。主CPU实现管理、坐标变换、轨迹生成和系统自诊断等; 从CPU实现所有关节的动作控制。主从控制方式系统实时性较好, 适于高精度、高速度控制, 但其系统扩展性较差, 维修困难。

### 分布式控制系统结构

按系统的性质和方式将系统控制分成几个模块, 每一个模块各有不同的控制任务和控制策略, 各模式之间可以是主从关系, 也可以是平等关系。

其主要思想是“分散控制, 集中管理”, 即系统对其总体目标和任务可以进行综合协调和分配, 并通过子系统的协调工作来完成控制任务, 整个系统在功能、逻辑和物理等方面都是分散的。 这种结构中, 子系统是由控制器和不同被控对象或设备构成的, 各个子系统之间通过网络等相互通讯。 分布式控制结构提供了一个开放、实时、精确的机器人控制系统。

* **优点:**
    * 系统灵活性好, 控制系统的危险性降低, 采用多处理器的分散控制, 有利于系统功能的并行执行, 提高系统的处理效率, 缩短响应时间。
    * 对于具有多自由度的工业机器人而言, 集中控制对各个控制轴之间的藕合关系处理得很好, 可以很简单地进行补偿。 但是, 当轴的数量增加到使控制算法变得很复杂时, 其控制性能会恶化。 而且, 当系统中轴的数量或控制算法变得很复杂时, 可能会导致系统的重新设计。 与之相比, 分布式结构的每一个运动轴都由一个控制器处理, 这意味着, 系统有较少的轴间祸合和较高的系统重构性。

---

## 3. 机器人的控制方式

机器人的工作原理就是模仿人的各种肢体动作、思维方式和控制决策能力。 从控制的角度, 机器人可以通过如下四种方式来达到这一目标。

### “示教再现”式

通过“示教盒”或人“手把手”两种方式教机械手如何动作, 控制器将示教过程记忆下来, 然后机器人就按照记忆周而复始地重复示教动作, 如喷涂机器人。

* **当对点位 (PTP) 控制的点焊、搬运机器人进行示教时**, 可以分开编制程序, 且能进行编辑、修改等工作, 但是机器人手部在作曲线运动而且位置精度要求较高时, 示教点数就会较多, 示教时间就会拉长, 且在每一个示教点处都要停止和启动, 因此就很难进行速度的控制。
* **当对用连续轨迹 (CP) 控制的弧焊、喷漆机器人进行示教时**, 示教操作一旦开始就不能中途停止, 必须不中断的连续进行到底, 且在示教途中很难进行局部的修改。 示教时, 可以是手把手示教, 也可通过示教盒示教。

### “可编程控制”式 (也称为离线编程控制)

“可编程控制”方式: 工作人员事先根据机器人的工作任务和运动轨迹编制控制程序, 然后将控制程序输入给机器人的控制器, 起动控制程序, 机器人就按照程序所规定的动作一步一步地去完成, 如果任务变更, 只要修改或重新编写控制程序, 非常灵活方便。 大多数工业机器人都是按照示教再现与可编程控制方式工作的。

离线编程采用部分传感技术, 主要依靠计算机图形学技术, 建立机器人工作模型, 对编程结果进行三维图形学动画仿真以检测编程可靠性, 最后将生成的代码传递给机器人控制柜控制机器人运行。 与示教编程相比, 离线编程可以减少机器人工作时间, 结合CAD技术, 简化编程。 国外机器人离线编程技术研究成熟, 各工业机器人产商都配有各自机器人专用的离线编程软件系统。 比如ABB的Robot studio仿真编程软件, 既可以做仿真分析又可以离线编程。 离线编程能够构造模拟的焊接环境。

### “遥控”式

由人用有线或无线遥控器控制机器人在人难以到达或危险的场所完成某项任务。 如防暴排险机器人、军用机器人、在有核辐射和化学污染环境工作的机器人等。

### “自主控制”式

是机器人控制中最高级、最复杂的控制方式, 它要求机器人在复杂的非结构化环境中具有识别环境和自主决策能力, 也就是要具有人的某些智能行为。

---

## 4. 机器人的控制策略与技术

### 工业机器人控制技术

* **控制的目的:** 是使被控对象产生控制者所期望的行为方式
* **控制的基本条件:** 是了解被控对象的特性
* **控制的实质:** 是对驱动器输出力矩的控制

### 按照是否有闭环反馈分为: 开环控制和闭环控制

**如果被控对象的模型能够精确知道, 但模型是变化的, 怎么办?**

* **如果模型的变化是可以预测的:** 开环预测控制
* **如果模型的变化是可以通过实时辨识的:** 开环辨识控制

**被控对象的特性(数学模型)不能完全确定或完全不能确定的情况下, 怎么办?**

以被控对象的实际输出构成某种评价标准来修正控制器的输入信号, 以使对象的输出接近期望值----**闭环反馈控制**

最常用的评价标准就是输入与输出(期望的输出与实际输出)之间的偏差

---

## 5. 工业机器人通信技术

**知识储备:** I/O是Input/Output的缩写, 即输入输出端口, 机器人可通过I/O与外部设备进行交互。

*   **数字量输入:** 各种开关信号反馈, 如按钮开关, 转换开关, 接近开关等; 传感器信号反馈, 如光电传感器, 光纤传感器; 还有接触器, 继电器触点信号反馈; 另外还有触摸屏里的开关信号反馈。
*   **数字量输出:** 控制各种继电器线圈, 如接触器, 继电器, 电磁阀; 控制各种指示类信号, 如指示灯, 蜂鸣器。

**ABB机器人I/O通讯的种类**

对于机器人系统而言, 输入信号通常由按钮、接近开关、传感器等产生并以电信号的形式输入系统之中, 从而触发机器人对应运动程序的执行; 输出信号由机器人系统产生, 以电信号的形式输出到外围设备, 通常应用与控制相应的信号指示灯、吸盘、抓手等执行元器件或者与PLC进行信号传递。

I/O信号可以分为数字量信号(digital signal)与模拟量信号(analog signal)两种基本类型, 数字量信号在时间上和数量上都是离散的, 只有0和1两种信号状态, 通常用于标识物理触点的断开与闭合两种状态。 模拟量信号在时间上和数量上都是连续的, 通常用于标识压力、流量、速度等连续变化的物理量。

**ABB机器人支持的通讯方式与协议**

ABB工业机器人默认配置是基于DeviceNet通信总线协议的I/O通信板卡, 通过此板卡实现主机控制系统与外围工业设备之间的通信。

---

## 6. PLC的程序执行过程

PLC的程序的执行过程一般可分为输入采样、程序执行和输出刷新三个阶段。

*   **在程序执行阶段**, PLC对程序按顺序进行扫描执行。 若程序用梯形图来表示, 则按先上后下, 先左后右的顺序进行。 每扫描到一条指令时, 所需要的输入状态或其它元素的状态分别由输入映像寄存器和元素映像寄存器中读出, 然后作由程序确定的逻辑运算或其它数字运算, 最后根据程序中有关的指令将运算结果存入确定的输出映像区有关单元。

---

## 7. PLC的编程语言与程序结构

目前已有越来越多的生产可编程序控制器的厂家提供符合IEC1131—3标准的产品, 有的厂家推出的在个人计算机上运行的“软件PLC”软件包也是按IEC1131-3标准设计的。

IEC1131-3详细地说明了句法、语义和下述5种编程语言的表达方式:

*   (1)顺序功能图
*   (2)梯形图
*   (3)功能块图
*   (4)指令表
*   (5)结构文本

标准中有两种图形语言——梯形图(LD)和功能块图(FBD), 还有两种文字语言——指令表(STL)和结构文本(ST), 可以认为顺序功能图(SFC)是一种结构块控制程序流程图。

---

## 8. PLC存储器的数据类型与寻址方式

**数据在存储器中存取的方式**

1.  **位、字节、字和双字**

    二进制数的1位(bit)只有0和1两种不同的取值, 可用来表示开关量(或称数字量)的两中不同的状态, 如触点的断开和接通, 线圈的通电和断电等。 如果该位为1, 则表示梯形图中对应的编程元件的线圈“通电”, 其常开触点接通, 常闭触点断开, 以后称该编程元件为1状态, 或对称该编程元件ON(接通)。 如果该位为0, 对应的编程元件的线圈和触点的状态与上述的相反, 称该编程元件为0状态, 或称该编程元件OFF(断开)。 位数据的数据类型为BOOL(布尔)型。

    8位二进制数组成1个字节, 其中第0位为最低位(LSB)、第7位为最高位(MSB)。 两个字节组成1个字(Word)。 两个字组成1个双字, 一般用二进制补码表示有符号数, 其最高位为符号位, 最高位为0时为正数, 为1时为负数, 最大的16位正数为7FFFH表示十六进制数。 字节、字和双字的取值范围见表。

    字、字节和双字对同一地址存取操作的比较: a)VB100 b)VW100 c)VDI00

### 西门子PLC的指令

#### 触点指令

1.  **标准触点指令**

    常开触点对应的存储器地址位为1状态时, 该触点闭合。 在语句表中, 分别用LD(Load, 装载)、A(And, 与)和O(Or, 或)指令来表示开始、串联和并联的常开触点(见表)。

    | 指令 | 类型 | 描述 |
    |---|---|---|
    | LD | bit | 装载电路开始的常开触点 |
    | A | bit | 与串联的常开触点 |
    | O | bit | 或并联的常开触点 |
    | LDN | bit | 非装载电路开始的常闭触点 |
    | AN | bit | 非与串联的常闭触点 |
    | ON | bit | 非或并联的常闭触点 |

#### 堆栈的基本概念

S7-200有1个9位的堆栈, 栈顶用来存储逻辑运算的结果, 下面的8位用来存储中间运算结果。 堆栈中的数据一般按“先进后出”的原则存取。

执行LD指令时, 将指令指定的位地址中的二进制数据装载入栈顶。 执行A(与)指令时, 将指令指定的位地址中的二进制数和栈顶中的二进制数相“与”, 结果存入栈顶。 执行O指令时, 将指令指定的位地址中的二进制数和栈顶中的二进制数相“或”, 结果存入栈顶。

执行常闭触点对应的LDN, AN和ON指令时, 取出指令指定的位地址中的二进制数据后, 将它取反(0变为1, 1变为0), 然后再做对应的装载、与、或操作。

| 指令 | 描述 |
|---|---|
| ALD | 装载与, 电路块串联连接 |
| OLD | 装载或, 电路块并联连接 |
| LPS | 入栈 |
| LRD | 读栈 |
| LPP | 出栈 |
| LDS n | 装载堆栈 |

常闭触点对应的存储器地址位为0状态时, 该触点闭合。 在语句表中, 分别用LDN(Load Not)、AN(And Not)和ON(Or Not)来表示开始、串联和并联的常闭触点。 触点符号中间的“/”表示常闭, 触点指令中变量的数据类型为BOOL型。 下图是触点与输出指令的例子。

#### OLD(Or Load)指令

触点的串并联指令只能将单个触点与别的触点电路串并联。 要想将下图由I3.2和/T16的触点组成的串联电路与它上面的电路并联, 首先需要完成两个串联电路块内部的“与”逻辑运算(即触点的串联), 这两个电路块都是用LD或LDN指令表示电路块的起始触点。 前两条指令执行完后,“与”运算的结果S0=/I1.4. I0.3存放在栈顶, 第3、4条指令执行完后,“与”运算的结果S1=I3.2./T16压入栈顶, 原来在栈顶的SO被推到堆栈的第2层, 第2层的数据被推到第3层……栈底的数据丢失。

OLD指令用逻辑“或”操作对堆栈第1层和第2层的数据相“或”, 即将两个串联电路块并联, 并将运算结果S2=SO+S1存入堆栈的顶部。 第3~第9层的数据依次向上移动一位(x表示不确定的值)。

OLD指令不需要地址, 它相当于需并联的两块电路右端的一段垂直连线。

#### ALD(And Load )指令

OLD后面的两条指令将两个触点并联, 运算结果S3=/C24+/I1.2压入栈顶, 栈中原来的数据依次向下推移, 栈底值被推出丢失。 ALD指令用逻辑“与”操作对堆栈第1层和第2层的数据相“与”, 即将两个电路块串联, 并将运算结果S4=S2·S3存入堆栈的顶部(见图, 图中×表示不确定的值)。

将电路块串并联时, 每增加一个用LD或LDN指令开始的电路块的运算结果, 堆栈中增加一个数据, 堆栈深度加1, 每执行一条ALD或OLD指令, 堆栈深度减1。

#### 其它堆栈操作指令

*   **入栈 (LPS, Logic Push)** 指令复制栈顶的值并将其压入堆栈的下一层, 栈中原来的数据依次向下推移, 栈底值被推出丢失(见图)。
*   **读栈 (LRD, Logic Read)** 指令将堆栈中第2层的数据复制到栈顶, 2—9层的数据不变, 但原栈顶值消失。
*   **出栈 (LPP, Logic Pop)** 指令使栈中各层的数据向上移动一层, 第2层的数据成为堆栈新的栈顶值, 原来栈顶的数据从栈内消失。
*   **装载堆栈 (LDS n, Load Stack, n: 1~8)** 指令复制堆栈内第n层的值到栈顶, 栈中原来数据依次向下推移, 栈底值被推出丢失。

与西门子PLC类似, 三菱PLC的堆栈指令分别为MPS、MRD、MPP 指令。

*   **指令的作用:**
    *   MPS(Push): 进栈指令;
    *   MRD(Read): 读栈指令;
    *   MPP(POP): 出栈指令。
*   **指令的说明:**
    *   MPS、MRD、MPP指令无编程元件。
    *   MPS、MPP指令成对出现, 可以嵌套。
    *   MRD指令可有可无, 也可以有两个或两个以上。

#### 置位与复位

执行S(Set, 置位或置1)与R(Reset, 复位或置0)指令时, 从指定的位地址开始的N个点的映像寄存器都被置位(变为1)或复位(变为0), N=1~255, 图中N=1。 如果图中I0.1的常开触点接通, Q0.3变为1并保持该状态, 即使I0.1的常开触点断开, 它也仍然保持1状态。 当I0.3的常开触点闭合时, Q0.3变为0, 并保持该状态, 即使I0.3的常开触点断开, 它也仍然保持0状态。

如果被指定复位的是定时器位(T)或计数器位(C), 将清除定时器/计数器的当前值。

#### 其他指令

1.  **取反 (NOT)**

    取反触点指令将它左边电路的逻辑运算结果取反, 运算结果若为1则变为0, 为0则变为1, 该指令没有操作数。 能流到达该触点时即停止, 若能流未到达该触点, 该触点给右侧供给能流。 NOT指令将堆栈顶部的值从0改为1, 或从1该为0。

2.  **跳变触点**

    正跳变触点检测到一次正跳变(触点的输入信号由0变为1)时, 或负跳变触点检测到一次负跳变(触点的输入信号由1变为0)时, 触点接通一个扫描周期。 正/负跳变指令的助记符分别为EU(Edge Up, 上升沿)和ED(Edge Down, 下降沿), 它们没有操作数, 触点符号中间的(“P”和“N”分别表示正跳变(Positive Transition)和负跳变(Negative Transition)。

#### 通电延时定时器指令

定时器、计数器的当前值、设定值均为16位有符号整数(INT), 允许的最大值为32767。

*   **通电延时定时器 (TON)** 输入端(IN)的输入电路接通时开始定时。 当前值大于等于PT(Preset Time, 预置时间)端指定的设定值时(PT=1 ~ 32767), 定时器位变为ON, 梯形图中对应定时器的常开触点闭合, 常闭触点断开。 达到设定值后, 当前值仍继续计数, 直到最大值32767。

    输入电路断开时, 定时器被复位, 当前值被清零, 常开触点断开。 第一次扫描时定时器位OFF, 当前值为0。 定时器有1ms、10ms和100ms三种分辨率, 分辨率取决于定时器号(见表)。 定时器的设定时间等于设定值与分辨率的乘积, 图中的T33为100ms定时器, 设定时间为100ms×3=0.3s。

    定时器和计数器的设定值的数据类型均为INT型, 除了常数外, 还可以用VW、IW等作它们的设定值。

    **定时器特性**

    | 定时器类型 | 用毫秒(ms)表示的分辨率 | 用秒(s)表示的最大当前值 | 定时器号 |
    |---|---|---|---|
    | TONR | 1 ms | 32.767 s | T0, T64 |
    |  | 10 ms | 327.67 s | T1 - T4, T65 - T68 |
    |  | 100 ms | 3276.7 s | T5 - T31, T69 - T95 |
    | TON, TOF | 1 ms | 32.767 s | T32, T96 |
    |  | 10 ms | 327.67 s | T33 - T36, T97 - T100 |
    |  | 100 ms | 3276.7 s | T37 - T63, T101 - T255 |

#### 断电延时定时器指令

断电延时定时器(TOF)用来在IN输入电路断开后延时一段时间, 再使定时器位OFF。 它用输入从ON到OFF的负跳变启动定时。

#### 计数器指令

1.  **加计数器 CTU**

    当复位输入(R)电路断开, 加计数(Count Up)脉冲输入(CU)电路由断开变为接通(即CU信号的上升沿), 计数器的当前值加1, 直至计数最大值32 767。 当前值大于等于设定值(PV)时, 该计数器位被置1。 当复位输入(R)ON时, 计数器被复位, 计数器位变为OFF, 当前值被清零(见图)。 在语句表中, 栈顶值是复位输入(R), 加计数输入值(CU)放在栈顶下面一层。

2.  **减计数器 CTD**

    在减计数 (Count Down)脉冲输入CD的上升沿(从OFF到ON), 从设定值开始, 计数器的当前值减1, 减至0时, 停止计数, 计数器位被置1。 装载输入(LD)为ON时, 计数器位被复位, 并把设定值装入当前值(见图)。 在语句表中, 栈顶值是装载输入LD, 减计数输入CD放在栈顶下面一层。

**定时器与计数器指令**

| 指令类型 | 指令 | 参数 |
|---|---|---|
| 通电延时定时器 | TON | TXXX, PT |
| 断电延时定时器 | TOF | TXXX, PT |
| 保持型通电延时定时器 | TONR | TXXX, PT |
| 加计数器 | CTU | CXXX, PV |
| 减计数器 | CTD | CXXX, PV |
| 加减计数器 | CTUD | CXXX, PV |

---

## 9. 工业机器人示教器操作与手动操作

### 单轴运动

一般地, 六轴工业机器人是由六个伺服电动机分别驱动机器人的六个关节轴, 那么每次手动操纵一个关节轴的运动, 就称之为单轴运动。

常见的六轴关节机器人, 第六轴是它的最末端轴, 所以通常第六轴的法兰盘用来安装机器人工具, 如焊接抢、抓手等, 因为是工具常常安装在最末端轴上, 所以有时称机器人工具为末端执行器。

### 线性运动

机器人的线性运动是指安装在机器人第六轴法兰盘上的工具的中心点(TCP)在空间中作线性运动。

出厂默认工业机器人的TCP点在机器人末端的法兰盘中心点, 通过安装末端执行器抓手, 然后将相应的TCP点做软件偏移匹配, 建立工具坐标系。

### 重定位运动

机器人的重定位运动是指: 机器人通过系统控制各个关节运动, 实现第六轴法兰盘上的工具中心点保持空间坐标位置不变, 而实现绕着坐标轴旋转来改变工业机器人工具姿态的运动, 也可以理解为机器人绕着工具TCP点作姿态调整的运动。

---

## 10. RAPID语言中数据类型与用法

Rapid语言中, 工具、位置、负载等不同的信息以数据形式保存。 数据由用户建立(也称作声明), 且可任意命名。 数据建立时需要明确数据的存储方式, 以分配其存储空间。 常用的数据存储方式, 即数据创建类型包括**变量**, **可变量**(也可称为永久数据对象)和**常量**三种。 分别用VAR、PERS和CONST表示。

*   **变量**型数据被声明时, 需要用VAR来修饰。 同时, 变量必须用常量表达式来初始化, 对于未定义初始化值的变量数据, 其值被设为默认值。

*   **可变量型数据PERS**最大的特点是, 即使程序再次执行此数据的声明语句, 数据都会保持最后被赋予的值。 在机器人执行的RAPID程序中也可以对可变量存储类型程序数据进行赋值的操作。 在程序执行以后, 赋值的结果会一直保持, 直到对其进行重新赋值。

*   **常量CONST**是指在程序执行期间, 数值不会改变的数据。 通常情况下, 会在程序的开始处直接初始化以方便使用。 常量的特点是在声明时已赋予了数值, 并不能在程序中进行修改, 除非手动修改。

    这句代码中, 标识符CONST表明了数据pi为常量, 其数据类型为num型, 初始值为3.14, 且此值不会发生变化。

### 4. Robtarget 分量

robtarget定义的对象用来描述机器人在空间中的位置数据, 通常用在移动机器人和附加轴的指令中。 通常情况下, 机器人能够以多种不同的方式达到这个位置, 此时, 可使用轴配置robconf来规定机器人达到这一位置的运动方向。 如果使用了轴配置分量数据后, 机器人的运动仍存在不明确之处, 则可以通过定义轴值来明确机器人的运动。 robtarget数据分量如下表所示。

| 分量 | 数据类型 | 描述 |
|---|---|---|
| trans | pos | 用mm来表示工具中心点的位置(x、y和z)。 规定相对于当前目标坐标系的位置, 包括程序位移。 如果未规定任何工件, 则为世界坐标系。 |
| rotation (Rot) | orient | 工具方位以四元数的形式表示(q1、q2、q3和q4)。 规定相对于当前目标坐标系的方位, 包括程序位移。 如果未规定任何工件, 则为世界坐标系。 |
| robconf | confdata | 机器人的轴配置(cf1、cf4、cf6和cfx)。 以轴1、轴4和轴6当前四分之一旋转的形式进行定义。 将第一个正四分之一旋转0到90°定义为0。 组件cfx的含义取决于机器人类型。 |
| extra | extjoint | 附加轴的位置。 各单个轴(eax_a、eax_b...eax_f)的位置 |

### 5. confdata

confdata数据类型对应的配置参数cf1、cf4、cf6和cfx来定义机器人的轴配置参数。

其中cf1、cf4、cf6的参数就是对应1、4、6关节轴的角度对应的象限代号。 把-360度到正360度分成8个象限, 每个象限占比90度, 象限0为四个旋转中的第一个, 0到90°, 处于始于零位置的正方向; 象限1为下一个旋转, 90到180°, 以此类推。 象限-1为旋转0°到(-90°), 以此类推, 如图所示, 图中箭头不代表方向。

例如: 一个机器人的第一关节轴为85°则cf1为0, 若第一关节轴为200°则cf1为2。 参数cf4和cf6和cf1类似; cfx用于从编号0到7的八种可能的机械臂姿态配置, 各种数字对应姿态对应下图1和2。

### 6. speeddata

当结合多种不同类型的移动时, 其中一个较低速率的运动会限制所有运动, 减小其他运动的速率, 使得所有的运动同时停止执行, 机器人达到某一个姿态。 系统中预定义了若干速度数据, 如下表所示。

| 名称 | TCP速度 | 旋转 | 线性外轴速度 | 旋转外轴速度 |
|---|---|---|---|---|
| v5 | 5mm/s | 500° /s | 5000mm/s | 1000° /s |
| v10 | 10mm/s | 500° /s | 5000mm/s | 1000° /s |
| v20 | 20mm/s | 500° /s | 5000mm/s | 1000° /s |
| v30 | 30mm/s | 500° /s | 5000mm/s | 1000° /s |
| v40 | 40mm/s | 500° /s | 5000mm/s | 1000° /s |
| v50 | 50mm/s | 500° /s | 5000mm/s | 1000° /s |
| v60 | 60mm/s | 500° /s | 5000mm/s | 1000° /s |
| v80 | 80mm/s | 500° /s | 5000mm/s | 1000° /s |

### 7. zonedata

zonedata定义的对象用于描述机器人工具中心点(TCP点)通过一个编程位置时, 飞越过并接近该位置所形成圆弧的轨迹参数。 若停止在一个准确的位置, 则zonedata预定义为fine。

fine也是机器人的特殊转弯数据, 指机器人TCP准确达到目标点, 在目标点速度降为零。 机器人动作有所停顿然后再向下运动, 转弯区数值越大, 机器人的动作路径就越圆滑与流畅。

以下示例介绍了数据类型zonedata:

```
VAR zonedata path := [ FALSE, 25, 40, 40, 10, 35, 5 ];
```

通过以下特征, 定义区域数据path:

(1) TCP路径的区域半径为25 mm。
(2) 工具重新定位的区域半径为40mm (TCP运动)。
(3) 外轴的区域半径为40mm(TCP运动)。

如果TCP静止不动, 或存在大幅度重新定位, 或存在有关该区域的外轴大幅度运动, 则应用以下规定: 工具重新定位的区域半径为10度; 线性外轴的区域半径为35mm; 旋转外轴的区域半径为5度。

同时, 将TCP路径的区域半径调整为40mm。 可按如下代码操作:

```
path.pzone_tcp := 40;
```

下面结合一个指令MoveJ, 来看下这个数据的用法。

```
MoveJ p2 v100 ZA1 tooll
```

MoveJ指令用于将机器人快速移动至目标点, 关于指令的细节将在后续章节进行详细的阐述。 指令中的ZA1就是一个预定义的zonedata类型的数据。

如同ZA1一样, 系统已经预定义了一些区域数据, 如下表所示。

| 名称 | TCP路径 | 方向 | 外轴 | 方向 | 线性轴/mm | 旋转轴 |
|---|---|---|---|---|---|---|
| Z0 | 0.3 | 0.3 | 0.3 | 0.03° | 0.3 | 0.03° |
| Z1 | 1 | 1 | 1 | 0.1° | 1 | 0.1° |
| Z5 | 5 | 8 | 8 | 0.8° | 8 | 0.8° |
| Z20 | 20 | 30 | 30 | 3° | 30 | 3° |
| Z50 | 50 | 75 | 75 | 7.5° | 75 | 7.5° |
| Z80 | 80 | 120 | 120 | 12° | 120 | 12° |
| Z100 | 100 | 150 | 150 | 15° | 150 | 15° |
| Z150 | 150 | 225 | 225 | 23° | 225 | 23° |
| Z200 | 200 | 300 | 300 | 30° | 300 | 30° |

---

## 11. RAPID程序的架构与分类

### 程序架构

Rapid程序的最高级别是任务, 一个任务下面只允许由一个任务程序, 在一个任务程序内部可以建立多个程序模块及系统模块。

程序模块由用户定义, 每个程序模块都可以包含程序数据、例行程序、中断程序和功能四种对象, 但不一定每个模块中都有这四种对象。 在建立这四种对象时候, 可以设定调用范围, 以实现不同程序模块之间数据、例行程序、中断程序和功能的相互调用。

### 程序分类

按用户程序有无返回值可将程序分为**有返回值程序**、**无返回值程序**和**软中断程序**。

*   其中, **无返回值程序**执行完毕后并不会返回任何类型的数值, 常用于语句中;
*   而**有返回值程序**在程序执行之后返回一个特定类型的数值, 可用于表达式中;
*   **软中断程序**则提供了一种中断响应方式, 通过将软中断程序与特定中断关联起来, 在产生该中断时, 系统自动执行相应的软中断程序。 而且, 软中断程序不能被调用。

注意, 用户程序需要生声明 积应吉阳应指阳玛皮夕称 返回值的数据类型、参
数和程序所包含的数 例行程序声明
也不同, 同样需要在程
程序声明中再声明其他

---

## 12. RAPID语言中的指令

### 1、机器人基本指令

*   **(1) MoveJ 运动指令**
    *   **功能:** 点到点运动
    *   **格式:** MoveJ [\Conc] ToPoint [\ID] Speed [\V] | [\T] Zone [\Z] [\Inpos] Tool [\WObj]
    *   **示例:**
        *   `MoveJ p1, vmax, z30, tool2` //工具tool2的TCP沿着一个非线性路径到位置p1, 速度数据是vmax, zone数据是z30
        *   `MoveJ*, vmax \T:=5, fine, grip3` //工具grip3的TCP沿着一个非线性路径运动到存储在指令中的停止点(用*标记), 整个运动需要5秒钟

*   **(2) 指令: MoveL 运动指令**
    *   **功能:** 直线运动
    *   **格式:** MoveL [\Conc] ToPoint [\ID] Speed [\V] | [\T] Zone [\Z] [\Inpos] Tool [\WObj] [\Corr]
    *   **示例:**
        *   `MoveL*, v2000 \V:=2200, z40 \Z:=45, grip3`
        *   `MoveL start, v2000, z40, grip3 \WObj:=fixture`

*   **(3) MoveC 运动指令**
    *   **功能:** 圆弧运动
    *   **格式:** MoveC [\Conc] CirPointToPoint [\ID] Speed [\V] | [\T] Zone [\z] [\Inpos] Tool [\Wobj] [\Corr]
    *   **示例:**
        *   `MoveLp1, v500, fine, tool1` //移动到圆弧的第一个点
        *   `MoveC p2, p3, v500, z20, tool1` //画第一个半圆
        *   `MoveCp4, p1, v500, fine, tool1` //画第二个半圆和第一个圆弧组成一个圆
        *   `MoveCp5, p6, v2000, fine\Inpos:=inpos50, grip3` //Grip3的TCP圆周运动到停止点p6, 当停止点fine的50%的位置条件和50%的速度条件满足的时候, 机器人认为它到达该点, 它等待条件满足最多等两秒

### 运动指令的使用示例

代码如下, 运动轨迹示意如图所示, 通过使用的工具数据是tool1, 工件坐标数

据是wobj1。

**指令:**

```
]]
MoveJ Pal, v100, fine, tool1\Wobj:=wobj1;
MoveL Pa2, v100, fine, tooll\Wobj:=wobj1;
MoveC Pa3, Pa4 v100, z10, tool1\Wobj:=wobj1;
MoveL Pa5, v120, fine, tool1\Wobj:=wobj1;
MoveC Pa6, Pa7 v80, z1, tool1\Wobj:=wobj1;
MoveL Pa8, v300, z100, tool1\Wobj:=wobj1;
MoveL Pa9, v150, z1, tool1\Wobj:=wobj1;
MoveJ Pal, v80, fine, tool1\Wobj:=wobj1;
]]
```

*   **(5) IF 指令**
    *   **功能:** 当前指令通过判断相应条件, 控制需要执行的相应指令, 是机器人程序流程基本指令
    *   **格式:** `IF Condition THEN... {ELSEIF Condition THEN...} [ELST...] ENDIF`
    *   **Condition:** 判断条件 (bool)
    *   **示例:**
        ```
        IF reg1>5 THEN
          set do1
          set do2
        ELSE
          Reset do1
          Reset do2
        ENDIF
        ```

*   **(6) WHILE 指令**
    *   **功能:** 当前指令通过判断相应条件, 如果符合判断条件执行循环内指令, 直至判断条件不满足才跳出循环, 继续执行循环以后指令, 需要注意, 当前指令存在死循环
    *   **格式:** `WHILE Condition DO ... ENDWHILE`
    *   **Condition:** 判断条件 (bool)

*   **(7) FOR 指令**
    *   **功能:** 当前指令通过循环判断标识从初始值逐渐更改最终值从而控制程序相应循环次数
    *   **格式:** `FOR Loop counter FROM Start value TO End value [STEP Step value] DO ... ENDFOR`
        *   Loop counter : 循环计数标识 (identifier)
        *   Start value: 标识初始值(num)
        *   End value: 标识最终值(num)
        *   [STEP Step value]: 计数更改值(num)

    如果不使用参变量[STEP], 循环标识每次更改值为1, 如果例用参变量[STEP], 循环标识每次更改值为参变量相应设置, 通常情况下, 初始值、最终值与更改值为整数, 循环判断标识使用i k j等小写字母

*   **(8) Reset 指令**
    *   **功能:** 将机器人相应数字输出信号值置为0, 与指令Set相对应是自动化重要组成部分。
    *   **格式:** `Reset signal`
        *   signal: 输出信号名称(signaldo)
    *   **示例:** `Reset do12`

*   **(9) Set 指令**
    *   **功能:** 将机器人相应数字输出信号值置为1, 与指令Reset相对应是自动化重要组成部分
    *   **格式:** `Set signal`
        *   signal: 机器人输出信号名称(signaldo)

*   **(10) WaitDI 指令**
    *   **功能:** 等待数字输入信号满足相应值, 达到通信目的, 是自动化生产的重要组成部分
    *   **格式:** `WaitDI Signal, Value [\MaxTime][\TimeFlag]`
        *   signal: 输出信号名称。(signaldo)
        *   Value: 输出信号值。(dionum)
        *   [\MaxTime]: 最长等待时间(num)
        *   [\TimeFlag]: 超出逻辑量 (bool)
    *   **示例:** `WaitDI di_Ready, 1` //机器人等待输入信号, 直到信号di_Ready值为1, 才执行随后指令

*   **(11) WaitDO 指令**
    *   **功能:** 等待数字输出信号满足相应值, 达到通信目的, 因为输出信号一般情况下受程序控制, 此指令很少使用
    *   **格式:** `WaitDO Signal,Value [\MaxTime][\TimeFlag]`

*   **(12) Accset 指令**
    *   **功能:** 当机器人运行速度改变时, 对所产生的相应加速度进行限制, 使机器人高速运行时更平缓, 但会延长循环时间, 系统默认值为AccSet100,100
    *   **格式:** `AccSet Acc, Ramp`
        *   Acc: 机器人加速度百分比(num)
        *   Ramp: 机器人加速度坡度(num)
    *   机器人加速度百分率值最小为20, 小于20以20计, 机器人加速度坡度值最小为10, 小于10以10计
    *   **例子:** `AccSet100,100; AccSet30,100; AccSet100,30.`


---

## 13. 事件管理器与Smart组件

工业机器人的前期方案设计和验证需要借助机器人仿真动画进行模拟, 而虚拟工作站中自动化设备的简单逻辑动作可通过事件管理器来实现。 事件管理器与Smart组件能够在离线仿真时通过I/O信号的变换来控制设备姿态的变换, 从而呈现仿真的动画效果。

---

## 14. 工业机器人集成案例

*   **码垛搬运机器人**可以分为龙门式码垛搬运机器人、悬臂式搬运机器人、侧壁式搬运机器人以及关节式码垛搬运机器人。
*   在设计马多机器人末端执行器时候, 需要考虑执行器与机器人的匹配关系, 主要从接口形式和自重两个方面入手。
*   **焊接机器人**可分为三种, 分别为: 点焊机器人、弧焊机器人和激光焊接机器人。
*   **弧焊机器人**的性能有着特殊的要求。 除在运动过程中速度的稳定性和轨迹精度是两项重要指标。 其他性能如下: 能够通过示教器设定焊接条件(电流、电压、速度等)以及摆动功能等。 摆动功能的主要目的是在焊缝宽度超过焊丝直径较多的时候通过焊枪的摆动去填充焊缝。
*   **激光焊接**是一种无接触的焊接方式, 与机器人电弧焊相比, 机器人激光焊的焊缝跟踪精度要求更高。

---

预祝同学们考试成功, 考研顺利!

---
